#!/bin/bash

source parse.sh

# 指定的proto文件
# 如果有指定文件，则只解析指定文件，否则解析所有文件
userPbFile=$1

# gen.sh所在目录
rootPath=$(cd $(dirname $0) && pwd)

# proto文件根目录
protoRootPath="${rootPath}/proto"
# 服务根目录
serviceRootPath="${rootPath}/service"
# 定义服务名的文件
serviceNameFilePath="${serviceRootPath}/name.go"
serviceNameTemplatePath="${rootPath}/name.template"



# 生成客户端
function genClientOfProto() {

    if [ -z ${packageName} ] || [ ${#funcInfos[@]} == 0 ]; then
        return 0
    fi

    clientFilePath="${serviceRootPath}/${packagePath}/${packageName}_client.go"

    echo "// Code generated by gen.sh. DO NOT EDIT.
package ${packageName}

import (
	\"context\"

	\"brainwave/pkg/grpc/client\"
	\"brainwave/pkg/grpc/service\"
	\"google.golang.org/grpc\"
)" > ${clientFilePath}

    funcName="";reqParam="";respParam="";streamResponse=false;
    i=0
    for val in ${funcInfos[@]};do
        case $i in
            0)
                ((i++))
                funcName=${val}
            ;;
            1)
                ((i++))
                reqParam=${val}
            ;;
            2)
                i=0
                respParam=${val}
                genRpcFunc
            ;;
        esac
    done

    return 0
}

function genRpcFunc() {

    echo "生成客户端方法：${funcName}(${reqParam}) ${respParam} "

    if [[ ${reqParam} =~ Stream ]]; then
        if [[ ${respParam} =~ Stream ]]; then
            genBothStreamFunc
        else
            genClientStreamFunc
        fi
    elif [[ ${respParam} =~ Stream ]]; then
        genServerStreamFunc
    else
        genNormalFunc
    fi
}

function genNormalFunc() {
    echo "
func ${funcName}Rpc(ctx context.Context, req *${reqParam}) (resp *${respParam}, err error) {

	var conn *grpc.ClientConn
	if conn, err = client.GetConn(ctx, service.Service_${serviceFullName}); err != nil {
		return
	}

	cli := New${serviceName}Client(conn)
	if resp, err = cli.${funcName}(ctx, req); err != nil {
		return
	}

	return
}" >> ${clientFilePath}
}

function genClientStreamFunc() {

    reqParam=${reqParam/Stream/}

    echo "
func ${funcName}Rpc(ctx context.Context, reqMsgs []*${reqParam}) (resp []*${respParam}, err error) {

	var conn *grpc.ClientConn
	if conn, err = client.GetConn(ctx, service.Service_${serviceFullName}); err != nil {
		return
	}

	cli := New${serviceName}Client(conn)
    var streamResponseClient ${serviceName}_${funcName}Client
	if streamResponseClient, err = cli.${funcName}(ctx); err != nil {
		return
	}

    for _, reqMsg := range reqMsgs {
        if err = streamResponseClient.Send(reqMsg); err != nil {
            return
        }
    }
    streamResponseClient.CloseSend()

	return
}" >> ${clientFilePath}

}

function genServerStreamFunc() {

    respParam=${respParam/Stream/}

    echo "
func ${funcName}Rpc(ctx context.Context, req *${reqParam}) (resp []*${respParam}, err error) {

	var conn *grpc.ClientConn
	if conn, err = client.GetConn(ctx, service.Service_${serviceFullName}); err != nil {
		return
	}

	cli := New${serviceName}Client(conn)
  var streamResponseClient ${serviceName}_${funcName}Client
	if streamResponseClient, err = cli.${funcName}(ctx, req); err != nil {
		return
	}

    for {
		msg, er := streamResponseClient.Recv()
		if er != nil {
			break
		}
        resp = append(resp, msg)
	}

	return
}" >> ${clientFilePath}

}

function genBothStreamFunc() {

    reqParam=${reqParam/Stream/}
    respParam=${respParam/Stream/}

    echo "
func ${funcName}Rpc(ctx context.Context, reqMsgs []*${reqParam}) (resp []*${respParam}, err error) {

	var conn *grpc.ClientConn
	if conn, err = client.GetConn(ctx, service.Service_${serviceFullName}); err != nil {
		return
	}

	cli := New${serviceName}Client(conn)
  var streamResponseClient ${serviceName}_${funcName}Client
	if streamResponseClient, err = cli.${funcName}(ctx); err != nil {
		return
	}

    doneCh := make(chan struct{})
    go func(){
        for {
            msg, err1 := streamResponseClient.Recv()
            if err1 != nil {
                break
            }
            resp = append(resp, msg)
	    }
        close(doneCh)
    }()

    for _, reqMsg := range reqMsgs {
        if err = streamResponseClient.Send(reqMsg); err != nil {
            return
        }
    }
    streamResponseClient.CloseSend()

    <-doneCh

	return
}" >> ${clientFilePath}
}

# 更新 service name
function updateServiceName() {
        echo "// Code generated by gen.sh. DO NOT EDIT.
package ${packageService}
type Name = string
    " > ${serviceNameFilePath}
    if [ -z ${serviceFullName} ]; then
        return 0
    fi

    if [ ! -f ${serviceNameFilePath} ]; then
        cp ${serviceNameTemplatePath} ${serviceNameFilePath}
    fi

    if [[ -z $( grep -w "Service_${serviceFullName}" "${serviceNameFilePath}" ) ]]; then
        echo "const Service_${serviceFullName} = \"${serviceFullName}\"
        " >> ${serviceNameFilePath}
    fi

    return 0
}

# 编译proto文件
function compileProto() {
    # 存放输出文件的目录
    servicePath="${serviceRootPath}/${packagePath}"
    mkdir -p ${servicePath}

    echo "正在编译：${filePath}"

    # 编译proto文件
    protoc --go_out=${servicePath} \
    --go-grpc_out=${servicePath} \
    --go_opt=paths=source_relative \
    --go-grpc_opt=paths=source_relative \
    --go-grpc_opt=require_unimplemented_servers=false \
    --proto_path=${protoRootPath} \
    ${fileName}
}

# 处理单个proto文件
function processProto() {

    filePath=${protoRootPath}/${fileName}

    if parseProto; then
        compileProto
        updateServiceName
        genClientOfProto
        return 0
    fi

    echo "解析出错：${filePath}"
    return 1
}

if [ -z ${userPbFile} ]; then
    # 没指定文件，处理所有的
    for f in `ls ${protoRootPath} | grep proto`
    do
        fileName=${f}
        processProto
    done
else
    # 处理指定的
    fileName=${userPbFile##*/}
    if [[ ${userPbFile} =~ / ]]; then
        protoRootPath=$(cd $(dirname ${userPbFile}) && pwd)
    fi

    processProto
fi


